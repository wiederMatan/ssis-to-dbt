"""Base agent protocol and shared types for the migration pipeline."""

from abc import ABC, abstractmethod
from enum import Enum
from typing import Any, Optional, TYPE_CHECKING
from pydantic import BaseModel, Field

if TYPE_CHECKING:
    from .context import MigrationContext


class AgentStatus(str, Enum):
    """Status of an agent's execution."""

    IDLE = "idle"
    RUNNING = "running"
    AWAITING_APPROVAL = "awaiting_approval"
    COMPLETED = "completed"
    FAILED = "failed"


class AgentResult(BaseModel):
    """Standard result from any agent execution."""

    success: bool
    status: AgentStatus
    data: dict[str, Any] = Field(default_factory=dict)
    errors: list[str] = Field(default_factory=list)
    warnings: list[str] = Field(default_factory=list)
    requires_approval: bool = False
    approval_context: Optional[dict[str, Any]] = None

    class Config:
        use_enum_values = True


class LoadPattern(str, Enum):
    """Detected load pattern for SSIS packages."""

    FULL_LOAD = "full_load"
    INCREMENTAL = "incremental"
    MERGE_SCD = "merge_scd"
    UNKNOWN = "unknown"


class LoadPatternDetails(BaseModel):
    """Details about detected load pattern."""

    pattern: LoadPattern
    confidence: float = Field(ge=0.0, le=1.0)
    indicators: list[str] = Field(default_factory=list)
    variables_used: list[str] = Field(default_factory=list)
    date_columns: list[str] = Field(default_factory=list)
    sync_table: Optional[str] = None


class GeneratedFile(BaseModel):
    """A file generated by the Builder agent."""

    path: str
    content: str
    file_type: str  # "sql", "yaml", "md"
    model_name: Optional[str] = None
    layer: Optional[str] = None  # "staging", "core", "sources"


class DbtCommandResult(BaseModel):
    """Result of a dbt command execution."""

    command: str
    success: bool
    return_code: int
    stdout: str
    stderr: str
    duration_seconds: float
    models_run: int = 0
    models_success: int = 0
    models_error: int = 0
    models_skipped: int = 0


class BaseAgent(ABC):
    """Base class for all migration agents."""

    def __init__(self, context: "MigrationContext"):
        self.context = context
        self.status = AgentStatus.IDLE
        self._name = self.__class__.__name__

    @property
    def name(self) -> str:
        """Agent name for logging and display."""
        return self._name

    @abstractmethod
    async def execute(self, input_data: dict[str, Any]) -> AgentResult:
        """
        Execute the agent's primary function.

        Args:
            input_data: Input data specific to this agent

        Returns:
            AgentResult with execution outcome
        """
        pass

    def get_required_approvals(self) -> list[str]:
        """
        Return list of actions that require human approval.

        Override in subclasses that need approval gates.
        """
        return []

    def log(self, message: str, level: str = "info") -> None:
        """Log a message with agent context."""
        # Will be connected to rich console in orchestrator
        print(f"[{self.name}] {message}")

    async def request_approval(
        self, action: str, details: dict[str, Any]
    ) -> bool:
        """
        Request human approval for an action.

        Args:
            action: Name of the action requiring approval
            details: Context to show the user

        Returns:
            True if approved, False otherwise
        """
        self.status = AgentStatus.AWAITING_APPROVAL
        self.context.request_approval(action, details)
        # Actual approval handling is done by the orchestrator
        return self.context.approval_responses.get(action, False)
